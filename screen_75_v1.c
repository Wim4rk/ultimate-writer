#include "screen.h"
#include "screen_75_v1.h"
#include <bcm2835.h>
#include <stdlib.h>
#include <stdio.h>


// Eink driver functions
//
// Note: despite being greatly inspired by waveshare's stock firmwire, this
// initiation phase has been quite modified. See IL0373 datasheet for more infos
// <https://www.smart-prototyping.com/image/data/9_Modules/EinkDisplay/GDEW0154T8/IL0373.pdf>
//
// This init phase has been optimized for the 7.2 inches screen. You'll need to tweak some commands
// to properly handle another screen. (The init phase has been commented out for more clarity).
//=====================

int sinit(void) {
  if(init_if() != 0){
    exit(-1);
  }
  sreset();

  ssend_command(POWER_SETTING); 
  /* 
   * Internal VDS_EN and VDG_EN.
   * VCOMH=VDH+VCOMDC, VGH=16V, VGL= -16V.
   * */
  ssend_data(0x37); 
  ssend_data(0x00);

  ssend_data(PANEL_SETTING);
  /* 160x296, LUTs from OTP, black/white/red, 
   * scan up, shift right, booster on */
  ssend_data(0xCF); 
  
  ssend_command(BOOSTER_SOFT_START);
  /*
   * The datasheet seems incorrect for this section.
   * Probably better to leave it as it was in wavshare's 
   * firmware.
   *
   * Phase A: Soft start period: 40ms, strength 1.
   * Minimum OFF time setting of GDR in phase A: 6.58uS.
   * Soft start period of phase B: 40ms, strength 2.
   * Minimum OFF time setting of GDR in phase B: 0.80uS.
   */
  ssend_data(0xc7);     
  ssend_data(0xcc);
  ssend_data(0x28);

  ssend_command(POWER_ON);
  swait_until_idle();

  ssend_command(PLL_CONTROL);
  /*
   * PLL clock: 50Hz.
   */
  ssend_data(0x3c);        

  ssend_command(TEMPERATURE_CALIBRATION);
  /*
   * Internal temperature sensor value.
   */
  ssend_data(0x00);

  ssend_command(VCOM_AND_DATA_INTERVAL_SETTING);
  /*
   * Vcom and data interval: 10 hsync (VBDW).
   */
  ssend_data(0x77);

  ssend_command(RESOLUTION_SETTING);
  /*
   * 12 periods.
   */
  ssend_data(0x22);

  ssend_command(RESOLUTION_SETTING);
  /*
   * Horizontal res: 640
   * Vertical res: 384
   */
  ssend_data(0x02);
  ssend_data(0x80);
  ssend_data(0x01);
  ssend_data(0x80);

  ssend_command(VCM_DC_SETTING);
  /*
   * VCOM DC value.
   */
  ssend_data(0x1E);

  ssend_command(TSSET);
  /*
   * Force set temperature for cascade.
   */
  ssend_data(0x03);  

  return 0;
}

void sreset(void){
  digital_write(RST_PIN, LOW);
  delay_ms(200);
  digital_write(RST_PIN, HIGH);
  delay_ms(200);
}

void ssend_command(unsigned char command){
  digital_write(DC_PIN, LOW);
  spi_transfer(command);
}

void ssend_data(unsigned char data){
  digital_write(DC_PIN, HIGH);
  spi_transfer(data);
}

void sdisplay_frame(const unsigned char* frame_buffer){
  unsigned char temp1, temp2;
  ssend_command(DATA_START_TRANSMISSION_1);
  for(int i = 0; i < 30720; i++) {   
    temp1 = frame_buffer[i];
    for(unsigned char j = 0; j < 8; j++) {
      if(temp1 & 0x80)
          temp2 = 0x03;
      else
          temp2 = 0x00;
      temp2 <<= 4;
      temp1 <<= 1;
      j++;
      if(temp1 & 0x80)
          temp2 |= 0x03;
      else
          temp2 |= 0x00;
      temp1 <<= 1;
      ssend_data(temp2); 
    }
  }
  //TODO: try this without refreshing
  ssend_command(DISPLAY_REFRESH);
  delay_ms(100);
  swait_until_idle();
}

void swait_until_idle(void) {
  while(digital_read(BUSY_PIN) == 0){
    delay_ms(100);
  }
}

void ssleep(void){
  ssend_command(POWER_OFF);
  swait_until_idle();
  ssend_command(DEEP_SLEEP);
  ssend_data(0xa5);
}

/*
 * LUTs-related code
 */
void sset_lut(void) {
  unsigned int count;     
  ssend_command(LUT_FOR_VCOM);
  for(count = 0; count < 44; count++) {
    ssend_data(lut_vcom0[count]);
  }
  
  ssend_command(LUT_WHITE_TO_WHITE);
  for(count = 0; count < 42; count++) {
    ssend_data(lut_ww[count]);
  }   
  
  ssend_command(LUT_BLACK_TO_WHITE);
  for(count = 0; count < 42; count++) {
    ssend_data(lut_bw[count]);
  } 

  ssend_command(LUT_WHITE_TO_BLACK);
  for(count = 0; count < 42; count++) {
    ssend_data(lut_wb[count]);
  } 

  ssend_command(LUT_BLACK_TO_BLACK);
  for(count = 0; count < 42; count++) {
    ssend_data(lut_bb[count]);
  } 
}

void sset_fast_lut(void) {
  unsigned int count;     
  ssend_command(LUT_FOR_VCOM);
  for(count = 0; count < 44; count++) {
    ssend_data(lut_vcom0_fast[count]);
  }
  
  ssend_command(LUT_WHITE_TO_WHITE);
  for(count = 0; count < 42; count++) {
    ssend_data(lut_ww_fast[count]);
  }   
  
  ssend_command(LUT_BLACK_TO_WHITE);
  for(count = 0; count < 42; count++) {
    ssend_data(lut_bw_fast[count]);
  } 

  ssend_command(LUT_WHITE_TO_BLACK);
  for(count = 0; count < 42; count++) {
    ssend_data(lut_wb_fast[count]);
  } 

  ssend_command(LUT_BLACK_TO_BLACK);
  for(count = 0; count < 42; count++) {
    ssend_data(lut_bb_fast[count]);
  } 
}

const int sorientation = ROTATE_0;

const unsigned char lut_vcom0[] =
{
0x40, 0x17, 0x00, 0x00, 0x00, 0x02,        
0x00, 0x17, 0x17, 0x00, 0x00, 0x02,        
0x00, 0x0A, 0x01, 0x00, 0x00, 0x01,        
0x00, 0x0E, 0x0E, 0x00, 0x00, 0x02,        
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,        
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,        
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_vcom0_fast[] =
{
0x00, 0x0E, 0x00, 0x00, 0x00, 0x01,        
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,        
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,        
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,        
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,        
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,        
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};



const unsigned char lut_ww[] ={
0x40, 0x17, 0x00, 0x00, 0x00, 0x02,
0x90, 0x17, 0x17, 0x00, 0x00, 0x02,
0x40, 0x0A, 0x01, 0x00, 0x00, 0x01,
0xA0, 0x0E, 0x0E, 0x00, 0x00, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_ww_fast[] ={
0xA0, 0x0E, 0x00, 0x00, 0x00, 0x01,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};


const unsigned char lut_bw[] ={
0x40, 0x17, 0x00, 0x00, 0x00, 0x02,
0x90, 0x17, 0x17, 0x00, 0x00, 0x02,
0x40, 0x0A, 0x01, 0x00, 0x00, 0x01,
0xA0, 0x0E, 0x0E, 0x00, 0x00, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     
};


const unsigned char lut_bw_fast[] ={
0xA0, 0x0E, 0x00, 0x00, 0x00, 0x01,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     
};

const unsigned char lut_bb[] ={
0x80, 0x17, 0x00, 0x00, 0x00, 0x02,
0x90, 0x17, 0x17, 0x00, 0x00, 0x02,
0x80, 0x0A, 0x01, 0x00, 0x00, 0x01,
0x50, 0x0E, 0x0E, 0x00, 0x00, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,        
};

const unsigned char lut_bb_fast[] ={
0x50, 0x0E, 0x00, 0x00, 0x00, 0x01,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     
};


const unsigned char lut_wb[] ={
0x80, 0x17, 0x00, 0x00, 0x00, 0x02,
0x90, 0x17, 0x17, 0x00, 0x00, 0x02,
0x80, 0x0A, 0x01, 0x00, 0x00, 0x01,
0x50, 0x0E, 0x0E, 0x00, 0x00, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,         
};

const unsigned char lut_wb_fast[] ={
0x50, 0x0E, 0x00, 0x00, 0x00, 0x01,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,         
};

